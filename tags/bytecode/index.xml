<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bytecode on Curious Stuff Blog by Sergio Anguita</title><link>https://curiousstuff.eu/tags/bytecode/</link><description>Recent content in bytecode on Curious Stuff Blog by Sergio Anguita</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Fri, 18 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://curiousstuff.eu/tags/bytecode/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a tiny Ethereum EVM in Go</title><link>https://curiousstuff.eu/post/creating-a-tiny-ethereum-evm-in-go/</link><pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/creating-a-tiny-ethereum-evm-in-go/</guid><description>The Ethereum Virtual Machine (EVM) The Ethereum Virtual Machine (EVM) is a vital component of the Ethereum blockchain ecosystem. It is responsible for executing smart contracts on the Ethereum network. Smart contracts are self-executing contracts with the terms of the agreement between the buyer and the seller being directly written into code.
The EVM can be thought of as a decentralized virtual computer, as it is distributed across the Ethereum network and run by all participating nodes.</description></item><item><title>EVM bytecode to Graph using Crytic CFG Builder</title><link>https://curiousstuff.eu/post/evm-bytecode-to-graph-using-crytic-cfg-builder/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/evm-bytecode-to-graph-using-crytic-cfg-builder/</guid><description>For this experiment, I choose to test the Crytic tool called evm_cfg_builder which is opensource and is available at https://github.com/crytic/evm_cfg_builder.
The next step, is to find a contract to analyze and see how it works. What a better way to try it out than using their own example contracts.
Finding a contract to analyze The source code is extracted from evm-cfg-builder at https://github.com/crytic/evm_cfg_builder/blob/master/examples/token.sol
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // from https://github.</description></item><item><title>Part 2: Building Ethereum EVM decompiler from scratch. Getting Code Blocks</title><link>https://curiousstuff.eu/post/part-2-building-ethereum-evm-decompiler-from-scratch.-getting-code-blocks/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/part-2-building-ethereum-evm-decompiler-from-scratch.-getting-code-blocks/</guid><description>In a previous post, Part 1: Building Ethereum EVM decompiler from scratch. Getting OPCODEs, I basically explained how EVM bytecode could be decoded from hexadecimal (0x...) format to some sort of assembly instructions. To make a little recap, we were able to convert input data from
1 0x363d3d373d3d3d363d73e38f942db7a1b4213d6213f70c499b59287b01f15af43d82803e903d91602b57fd5bf3 to EVM assembly instructions like
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 0x0000 CALLDATASIZE 0x0001 RETURNDATASIZE 0x0002 RETURNDATASIZE 0x0003 CALLDATACOPY 0x0004 RETURNDATASIZE 0x0005 RETURNDATASIZE 0x0006 RETURNDATASIZE 0x0007 CALLDATASIZE 0x0008 RETURNDATASIZE 0x0009 PUSH20 0xE38F942DB7A1B4213D6213F70C499B59287B01F1 0x001E GAS 0x001F DELEGATECALL 0x0020 RETURNDATASIZE 0x0021 DUP3 0x0022 DUP1 0x0023 RETURNDATACOPY 0x0024 SWAP1 0x0025 RETURNDATASIZE 0x0026 SWAP2 0x0027 PUSH1 0x2B 0x0029 JUMPI 0x002A REVERT 0x002B JUMPDEST 0x002C RETURN Example: Proxy contract taken from Ethereum Mainnet at address 0x3cdd26204e114c17823d82180e5ca3f299f18d22.</description></item><item><title>Part 1: Building Ethereum EVM decompiler from scratch. Getting OPCODEs</title><link>https://curiousstuff.eu/post/part-1-building-ethereum-evm-decompiler-from-scratch.-getting-opcodes/</link><pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/part-1-building-ethereum-evm-decompiler-from-scratch.-getting-opcodes/</guid><description>What is the decompilation process? The decompilation process involves going back to the original source code from compiled source code so that security engineers might have a better understanding of the programs instead of working directly with machine code; in this context of EVM, the goal is to convert EVM bytecode into solidity like code.
The challenge Compilation back to the original source code is impossible because all variable names, type names and even function names are removed.</description></item><item><title>Converting EVM bytecode to OPCODES in microseconds</title><link>https://curiousstuff.eu/post/converting-evm-bytecode-to-opcodes-in-microseconds/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/converting-evm-bytecode-to-opcodes-in-microseconds/</guid><description>Decompiling EVM Bytecode The process of decompiling an ethereum application can be very expensive. When you start an analysis process, you can take as a basis the network bytecode or the source code in Solidity. Doing a white box analysis is generally less expensive and requires programming knowledge in Solidity only. A bytecode analysis, however, requires low-level knowledge, understanding the operation of opcodes, EVM instructions, the stack, memory and storage modules, etc.</description></item><item><title>Understanding EVM: an introduction to Ethereum OPCODES</title><link>https://curiousstuff.eu/post/understanding-evm-an-introduction-to-ethereum-opcodes/</link><pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/understanding-evm-an-introduction-to-ethereum-opcodes/</guid><description>The Ethereum Virtual Machine or EVM The Ethereum Virtual Machine is the software platform that developers can use to create decentralized applications (DApps) on Ethereum. At any given block in the chain, Ethereum has one and only one &amp;lsquo;canonical&amp;rsquo; state, and the EVM is what defines the rules for computing a new valid state from block to block.
The EVM design simplified The EVM behaves as a mathematical function would: Given an input, it produces a deterministic output.</description></item></channel></rss>