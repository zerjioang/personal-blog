<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blockchain on Curious Stuff Blog by Sergio Anguita</title><link>https://curiousstuff.eu/categories/blockchain/</link><description>Recent content in Blockchain on Curious Stuff Blog by Sergio Anguita</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><atom:link href="https://curiousstuff.eu/categories/blockchain/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a tiny Ethereum EVM in Go</title><link>https://curiousstuff.eu/post/creating-a-tiny-ethereum-evm-in-go/</link><pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/creating-a-tiny-ethereum-evm-in-go/</guid><description>The Ethereum Virtual Machine (EVM) The Ethereum Virtual Machine (EVM) is a vital component of the Ethereum blockchain ecosystem. It is responsible for executing smart contracts on the Ethereum network. Smart contracts are self-executing contracts with the terms of the agreement between the buyer and the seller being directly written into code.
The EVM can be thought of as a decentralized virtual computer, as it is distributed across the Ethereum network and run by all participating nodes.</description></item><item><title>Autodetecting Unlocked Compiler Versions in Solidity</title><link>https://curiousstuff.eu/post/autodetecting-unlocked-compiler-versions-in-solidity/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/autodetecting-unlocked-compiler-versions-in-solidity/</guid><description>I want to show you how source code analyzers works with a simple example. Let&amp;rsquo;s build an analyzer that will check if Solidity source files contains a floating pragma declaration or not. There are some steps we need to follow, such as finding or building a good Solidity grammar file, parse the input content, build a parse tree, process the tree, and finally, find issues. All the process is explained below.</description></item><item><title>EVM bytecode to Graph using Crytic CFG Builder</title><link>https://curiousstuff.eu/post/evm-bytecode-to-graph-using-crytic-cfg-builder/</link><pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/evm-bytecode-to-graph-using-crytic-cfg-builder/</guid><description>For this experiment, I choose to test the Crytic tool called evm_cfg_builder which is opensource and is available at https://github.com/crytic/evm_cfg_builder.
The next step, is to find a contract to analyze and see how it works. What a better way to try it out than using their own example contracts.
Finding a contract to analyze The source code is extracted from evm-cfg-builder at https://github.com/crytic/evm_cfg_builder/blob/master/examples/token.sol
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // from https://github.</description></item><item><title>Part 2: Building Ethereum EVM decompiler from scratch. Getting Code Blocks</title><link>https://curiousstuff.eu/post/part-2-building-ethereum-evm-decompiler-from-scratch.-getting-code-blocks/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/part-2-building-ethereum-evm-decompiler-from-scratch.-getting-code-blocks/</guid><description>In a previous post, Part 1: Building Ethereum EVM decompiler from scratch. Getting OPCODEs, I basically explained how EVM bytecode could be decoded from hexadecimal (0x...) format to some sort of assembly instructions. To make a little recap, we were able to convert input data from
1 0x363d3d373d3d3d363d73e38f942db7a1b4213d6213f70c499b59287b01f15af43d82803e903d91602b57fd5bf3 to EVM assembly instructions like
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 0x0000 CALLDATASIZE 0x0001 RETURNDATASIZE 0x0002 RETURNDATASIZE 0x0003 CALLDATACOPY 0x0004 RETURNDATASIZE 0x0005 RETURNDATASIZE 0x0006 RETURNDATASIZE 0x0007 CALLDATASIZE 0x0008 RETURNDATASIZE 0x0009 PUSH20 0xE38F942DB7A1B4213D6213F70C499B59287B01F1 0x001E GAS 0x001F DELEGATECALL 0x0020 RETURNDATASIZE 0x0021 DUP3 0x0022 DUP1 0x0023 RETURNDATACOPY 0x0024 SWAP1 0x0025 RETURNDATASIZE 0x0026 SWAP2 0x0027 PUSH1 0x2B 0x0029 JUMPI 0x002A REVERT 0x002B JUMPDEST 0x002C RETURN Example: Proxy contract taken from Ethereum Mainnet at address 0x3cdd26204e114c17823d82180e5ca3f299f18d22.</description></item><item><title>Part 1: Building Ethereum EVM decompiler from scratch. Getting OPCODEs</title><link>https://curiousstuff.eu/post/part-1-building-ethereum-evm-decompiler-from-scratch.-getting-opcodes/</link><pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/part-1-building-ethereum-evm-decompiler-from-scratch.-getting-opcodes/</guid><description>What is the decompilation process? The decompilation process involves going back to the original source code from compiled source code so that security engineers might have a better understanding of the programs instead of working directly with machine code; in this context of EVM, the goal is to convert EVM bytecode into solidity like code.
The challenge Compilation back to the original source code is impossible because all variable names, type names and even function names are removed.</description></item><item><title>Hunting RUG PULLs in Binance Smart Chain by code reviewing</title><link>https://curiousstuff.eu/post/hunting-rug-pulls-in-binance-smart-chain-by-code-reviewing/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/hunting-rug-pulls-in-binance-smart-chain-by-code-reviewing/</guid><description>What is a rug pull? We could define a rug pull as:
&amp;ldquo;Rug pulls are a lucrative scam in which a crypto developer promotes a new project—usually a new token—to investors, and then disappears with tens of millions or even hundreds of millions of dollars.&amp;rdquo;
Source: https://fortune.com/2022/03/02/crypto-scam-rug-pull-what-is-it Introducing POKELON: another scam According to creator description:
$POKELON is a BEP20 token that parodies wildly popular trends in DeFi and Gaming culture and brings them to life as an interactive, NFT Collectible Card Game.</description></item><item><title>Converting EVM bytecode to OPCODES in microseconds</title><link>https://curiousstuff.eu/post/converting-evm-bytecode-to-opcodes-in-microseconds/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/converting-evm-bytecode-to-opcodes-in-microseconds/</guid><description>Decompiling EVM Bytecode The process of decompiling an ethereum application can be very expensive. When you start an analysis process, you can take as a basis the network bytecode or the source code in Solidity. Doing a white box analysis is generally less expensive and requires programming knowledge in Solidity only. A bytecode analysis, however, requires low-level knowledge, understanding the operation of opcodes, EVM instructions, the stack, memory and storage modules, etc.</description></item><item><title>Crawling Ethereum Blockchain for automated Smart Contract Extraction</title><link>https://curiousstuff.eu/post/crawling-ethereum-blockchain-for-automated-smart-contract-extraction/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/crawling-ethereum-blockchain-for-automated-smart-contract-extraction/</guid><description>In this article I&amp;rsquo;m going to show you how an automated data extraction can be dome for massive data analysis processes. The goal is to download all interesting Blockchain information as a processable file like a CSV. I&amp;rsquo;ll guide you throw the process of making it possible.
Requirements To be able to crawl the Blockchain data, we must have first a ledger peer syncronized and running. If you dont have one, you can check this guide about how to setup one.</description></item><item><title>Running an Ethereum Rinkeby full node in 2022</title><link>https://curiousstuff.eu/post/running-an-ethereum-rinkeby-full-node-in-2022/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/running-an-ethereum-rinkeby-full-node-in-2022/</guid><description>What is Rinkeby Testnet Rinkeby is an Ethereum test network that allows for blockchain development testing before deployment on Mainnet, the main Ethereum network.
The Proof-of-Authority test network was established in April 2017. It uses the Clique PoA consensus protocol, and is maintained by the Geth developer team.
The network is supported by Geth, Nethermind and Hyperledger Besu.
Some features of the network are:
Testnet / Live: Test Chain ID: 4 Network ID: 4 Live Since: April 2017 Block time: 15 seconds Consensus / block proposer: PoA – Proof-of-Authority Permissioned: Yes Governance / Authorities: Known developers who sign the blocks Meaning of PoA:</description></item><item><title>Benchmarking Go Ethereum account creation in Android</title><link>https://curiousstuff.eu/post/benchmarking-go-ethereum-account-creation-in-android/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/benchmarking-go-ethereum-account-creation-in-android/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>How to run native Go code In Android and bench results!&lt;/p></description></item><item><title>Introducción al concepto Self Sovereign Identity</title><link>https://curiousstuff.eu/post/introducci%C3%B3n-al-concepto-self-sovereign-identity/</link><pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate><guid>https://curiousstuff.eu/post/introducci%C3%B3n-al-concepto-self-sovereign-identity/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>Breve introducción al concepto de SSI o Self Sovereign Identity.&lt;/p></description></item></channel></rss>